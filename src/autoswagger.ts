import { serializeV6Middleware, serializeV6Handler } from "./adonishelpers.js";
import {
  InterfaceParser,
  ModelParser,
  CommentParser,
  RouteParser,
  ValidatorParser,
  EnumParser,
} from "./parsers/index.js";
import _, { isEmpty, isUndefined } from "lodash";

import type { options, AdonisRoutes, v6Handler, AdonisRoute } from "./types.js";

import { mergeParams, formatOperationId } from "./helpers.js";
import ExampleGenerator, { ExampleInterfaces } from "./example.js";
import {
  getFiles,
  json,
  docs,
  jsonToYaml,
  readFile,
  writeFile,
} from "./file.js";
import {
  getEnums,
  getInterfaces,
  getModels,
  getSchemas,
  getSerializers,
  getValidators,
} from "./schema.js";
import { rapidoc, scalar, stoplight, ui } from "./ui.js";
import path from "path";
import fs from "fs";
import { startCase } from "lodash";
import HTTPStatusCode from "http-status-code";

export class AutoSwagger {
  private options: options;
  private schemas: Record<string, any> = {};
  private commentParser: CommentParser;
  private modelParser: ModelParser;
  private interfaceParser: InterfaceParser;
  private enumParser: EnumParser;
  private routeParser: RouteParser;
  private validatorParser: ValidatorParser;
  private customPaths: Record<string, any> = {};

  // UI
  ui = ui;
  rapidoc = rapidoc;
  scalar = scalar;
  stoplight = stoplight;

  // File
  jsonToYaml = jsonToYaml;
  json = json;
  writeFile = writeFile;
  readFile = readFile;
  docs = docs;
  getFiles = getFiles;

  // Schema
  getSchemas = getSchemas;
  getValidators = getValidators;
  getSerializers = getSerializers;
  getModels = getModels;
  getInterfaces = getInterfaces;
  getEnums = getEnums;

  /**
   * Generate swagger spec
   * @param adonisRoutes
   * @param options
   * @returns
   */
  private async generate(adonisRoutes: AdonisRoutes, options: options) {
    this.options = {
      ...{
        snakeCase: true,
        preferredPutPatch: "PUT",
        debug: false,
      },
      ...options,
    };

    const routes = adonisRoutes.root;
    this.options.appPath = this.options.path + "app";

    try {
      const pj = fs.readFileSync(path.join(this.options.path, "package.json"));

      const pjson = JSON.parse(pj.toString());
      if (pjson.imports) {
        Object.entries(pjson.imports).forEach(([key, value]) => {
          const k = (key as string).replaceAll("/*", "");
          this.customPaths[k] = (value as string)
            .replaceAll("/*.js", "")
            .replaceAll("./", "");
        });
      }
    } catch (e) {
      console.error(e);
    }

    this.commentParser = new CommentParser(this.options);
    this.routeParser = new RouteParser(this.options);
    this.modelParser = new ModelParser(this.options.snakeCase);
    this.interfaceParser = new InterfaceParser(this.options.snakeCase);
    this.validatorParser = new ValidatorParser();
    this.enumParser = new EnumParser();
    this.schemas = await this.getSchemas();
    if (this.options.debug) {
      console.log(this.options);
      console.log("Found Schemas", Object.keys(this.schemas));
      console.log("Using custom paths", this.customPaths);
    }
    this.commentParser.exampleGenerator = new ExampleGenerator(this.schemas);

    const docs: Record<string, any> = {
      openapi: "3.0.0",
      info: options.info || {
        title: options.title,
        version: options.version,
        description:
          options.description ||
          "Generated by AdonisJS AutoSwagger https://github.com/ad-on-is/adonis-autoswagger",
      },

      components: {
        responses: {
          Forbidden: {
            description: "Access token is missing or invalid",
          },
          Accepted: {
            description: "The request was accepted",
          },
          Created: {
            description: "The resource has been created",
          },
          NotFound: {
            description: "The resource has been created",
          },
          NotAcceptable: {
            description: "The resource has been created",
          },
        },
        securitySchemes: this.options.securitySchemes
          ? this.options.securitySchemes
          : {
              BearerAuth: {
                type: "http",
                scheme: "bearer",
              },
              BasicAuth: {
                type: "http",
                scheme: "basic",
              },
              ApiKeyAuth: {
                type: "apiKey",
                in: "header",
                name: "X-API-Key",
              },
            },
        schemas: this.schemas,
      },
      paths: {},
      tags: [],
    };
    let paths: Record<string, any> = {};

    let sscheme = "BearerAuth";
    if (this.options.defaultSecurityScheme) {
      sscheme = this.options.defaultSecurityScheme;
    }

    let securities: Record<string, any> = {
      auth: { [sscheme]: ["access"] },
      "auth:api": { [sscheme]: ["access"] },
      ...this.options.authMiddlewares
        ?.map((am) => ({
          [am]: { [sscheme]: ["access"] },
        }))
        .reduce((acc, val) => ({ ...acc, ...val }), {}),
    };

    let globalTags: any[] = [];

    if (this.options.debug) {
      console.log("Route annotations:");
      console.log("Checking if controllers have propper comment annotations");
      console.log("-----");
    }

    for await (const route of routes) {
      let ignore: boolean = false;
      for (const i of options.ignore) {
        if (
          route.pattern == i ||
          (i.endsWith("*") && route.pattern.startsWith(i.slice(0, -1))) ||
          (i.startsWith("*") && route.pattern.endsWith(i.slice(1)))
        ) {
          ignore = true;
          break;
        }
      }
      if (ignore) continue;

      let security: any[] = [];
      const responseCodes: Record<string, any> = {
        GET: "200",
        POST: "201",
        DELETE: "202",
        PUT: "204",
      };

      if (!Array.isArray(route.middleware)) {
        route.middleware = serializeV6Middleware(route.middleware) as string[];
      }

      (route.middleware as string[]).forEach((m) => {
        if (typeof securities[m] !== "undefined") {
          security.push(securities[m]);
        }
      });

      let { tags, parameters, pattern } = this.routeParser.extractInfos(
        route.pattern
      );

      tags.forEach((tag) => {
        if (globalTags.filter((e) => e.name === tag).length > 0) return;
        if (tag === "") return;
        globalTags.push({
          name: tag,
        });
      });

      let { sourceFile, action, customAnnotations, operationId } =
        await this.getDataBasedOnAdonisVersion(route);

      route.methods.forEach((method: string) => {
        let responses: Record<string, any> = {};
        if (method === "HEAD") return;

        if (
          route.methods.includes("PUT") &&
          route.methods.includes("PATCH") &&
          method !== this.options.preferredPutPatch
        )
          return;

        let description: string = "";
        let summary: string = "";
        let tag: string = "";

        if (security.length > 0) {
          responses["401"] = {
            description: `Returns **401** (${HTTPStatusCode.getMessage(401)})`,
          };
          responses["403"] = {
            description: `Returns **403** (${HTTPStatusCode.getMessage(403)})`,
          };
        }

        let requestBody: Record<string, any> = {
          content: {
            "application/json": {},
          },
        };

        let actionParams: Record<string, any> = {};

        if (action !== "" && typeof customAnnotations[action] !== "undefined") {
          description = customAnnotations[action].description;
          summary = customAnnotations[action].summary;
          operationId = customAnnotations[action].operationId;
          responses = { ...responses, ...customAnnotations[action].responses };
          requestBody = customAnnotations[action].requestBody;
          actionParams = customAnnotations[action].parameters;
          tag = customAnnotations[action].tag;
        }
        parameters = mergeParams(parameters, actionParams);

        if (tag != "") {
          globalTags.push({
            name: tag.toUpperCase()
          });
          tags = [tag.toUpperCase()];
        }

        if (isEmpty(responses)) {
          responses[responseCodes[method]] = {
            description: HTTPStatusCode.getMessage(responseCodes[method]),
            content: {
              "application/json": {},
            },
          };
        } else {
          if (
            typeof responses[responseCodes[method]] !== "undefined" &&
            typeof responses[responseCodes[method]]["summary"] !== "undefined"
          ) {
            if (summary === "") {
              summary = responses[responseCodes[method]]["summary"];
            }
            delete responses[responseCodes[method]]["summary"];
          }
          if (
            typeof responses[responseCodes[method]] !== "undefined" &&
            typeof responses[responseCodes[method]]["description"] !==
              "undefined"
          ) {
            description = responses[responseCodes[method]]["description"];
          }
        }

        if (action !== "" && summary === "") {
          // Solve toLowerCase undefined exception
          // https://github.com/ad-on-is/adonis-autoswagger/issues/28
          tags[0] = tags[0] ?? "";

          switch (action) {
            case "index":
              summary = "Get a list of " + tags[0].toLowerCase();
              break;
            case "show":
              summary = "Get a single instance of " + tags[0].toLowerCase();
              break;
            case "update":
              summary = "Update " + tags[0].toLowerCase();
              break;
            case "destroy":
              summary = "Delete " + tags[0].toLowerCase();
              break;
            case "store":
              summary = "Create " + tags[0].toLowerCase();
              break;
            // frontend defaults
            case "create":
              summary = "Create (Frontend) " + tags[0].toLowerCase();
              break;
            case "edit":
              summary = "Update (Frontend) " + tags[0].toLowerCase();
              break;
          }
        }

        action = startCase(action);

        const sf: string = sourceFile.split("/").at(-1).replace(".ts", "");
        let m: Record<string, any> = {
          summary: `${summary}${action !== "" ? ` ${action}` : "route"}`,
          description:
            description + "\n\n _" + sourceFile + "_ - **" + action + "**",
          operationId: operationId,
          parameters: parameters,
          tags: tags,
          responses: responses,
          security: security,
        };

        if (method !== "GET" && method !== "DELETE") {
          m["requestBody"] = requestBody;
        }

        pattern = pattern.slice(1);
        if (pattern === "") {
          pattern = "/";
        }

        paths = {
          ...paths,
          [pattern]: { ...paths[pattern], [method.toLowerCase()]: m },
        };
      });
    }

    // filter unused tags
    const usedTags = _.uniq(
      Object.entries(paths)
        .map(
          ([p, val]: [string, Record<string, any>]) =>
            Object.entries(val)[0][1].tags
        )
        .flat()
    );

    docs.tags = globalTags.filter((tag) => usedTags.includes(tag.name));
    docs.paths = paths;
    return docs;
  }

  /**
   * Get data based on adonis version
   * @param route AdonisRoute
   * @returns
   */
  private async getDataBasedOnAdonisVersion(route: AdonisRoute) {
    let sourceFile: string = "";
    let action: string = "";
    let customAnnotations: Record<string, any>;
    let operationId: string = "";
    if (
      route.meta.resolvedHandler !== null &&
      route.meta.resolvedHandler !== undefined
    ) {
      if (
        typeof route.meta.resolvedHandler.namespace !== "undefined" &&
        route.meta.resolvedHandler.method !== "handle"
      ) {
        sourceFile = route.meta.resolvedHandler.namespace;

        action = route.meta.resolvedHandler.method;
        // If not defined by an annotation, use the combination of "controllerNameMethodName"
        if (action !== "" && isUndefined(operationId) && route.handler) {
          operationId = formatOperationId(route.handler as string);
        }
      }
    }

    let v6handler: v6Handler = <v6Handler>route.handler;
    if (
      v6handler.reference !== null &&
      v6handler.reference !== undefined &&
      v6handler.reference !== ""
    ) {
      if (!Array.isArray(v6handler.reference)) {
        // handles magic strings
        // router.resource('/test', '#controllers/test_controller')
        [sourceFile, action] = (v6handler.reference as string).split(".");
        const split: string[] = sourceFile.split("/");

        if (split[0].includes("#")) {
          sourceFile = sourceFile.replaceAll(
            split[0],
            this.customPaths[split[0]]
          );
        } else {
          sourceFile = this.options.appPath + "/controllers/" + sourceFile;
        }
        operationId = formatOperationId(v6handler.reference);
      } else {
        // handles lazy import
        // const TestController = () => import('#controllers/test_controller')
        v6handler = await serializeV6Handler(v6handler);
        action = v6handler.method;
        sourceFile = v6handler.moduleNameOrPath;
        operationId = formatOperationId(sourceFile + "." + action);
        const split: string[] = sourceFile.split("/");
        if (split[0].includes("#")) {
          sourceFile = sourceFile.replaceAll(
            split[0],
            this.customPaths[split[0]]
          );
        } else {
          sourceFile = this.options.appPath + "/" + sourceFile;
        }
      }
    }

    if (sourceFile !== "" && action !== "") {
      sourceFile = sourceFile.replace("App/", "app/") + ".ts";
      sourceFile = sourceFile.replace(".js", "");

      customAnnotations = await this.commentParser.getAnnotations(
        sourceFile,
        action
      );
    }
    if (
      typeof customAnnotations !== "undefined" &&
      typeof customAnnotations.operationId !== "undefined" &&
      customAnnotations.operationId !== ""
    ) {
      operationId = customAnnotations.operationId;
    }
    if (this.options.debug) {
      if (sourceFile !== "") {
        console.log(
          typeof customAnnotations !== "undefined" &&
            !_.isEmpty(customAnnotations)
            ? `\x1b[32m✓ FOUND for ${action}\x1b[0m`
            : `\x1b[33m✗ MISSING for ${action}\x1b[0m`,

          `${sourceFile} (${route.methods[0].toUpperCase()} ${route.pattern})`
        );
      }
    }
    return { sourceFile, action, customAnnotations, operationId };
  }

}
